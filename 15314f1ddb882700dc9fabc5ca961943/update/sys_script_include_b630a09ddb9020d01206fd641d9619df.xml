<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_illu2_illumio.IllumioUtils</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <name>IllumioUtils</name>
        <script><![CDATA[gs.include("IllumioConstants");
var IllumioUtils = Class.create();
IllumioUtils.prototype = {
    initialize: function() {},

    VALID_IP_REGEX: /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/,
    /**
     * Updates the job with given job content
     * @param {String} jobId System id of the scheduled job
     * @param {JSON} jobContent Object to add in the job record
     */
    updateJobRecord: function(jobId, jobContent) {
        var jobGr = new GlideRecord('x_illu2_illumio_illumio_scheduled_jobs');

        if (jobGr.get(jobId)) {

            if (jobGr.job_status == "cancelled") return;

            // Update only if job is not invalidated
            if (jobGr.job_status != 'failed') {
                for (var key in jobContent) {
                    if (jobContent.hasOwnProperty(key)) {
                        if (key != "logs") {
                            jobGr[key] = jobContent[key];
                        } else {
                            jobGr[key] += '\n[' + new Date(new GlideDateTime().getNumericValue()).toISOString() + '] ' + jobContent[key];
                        }
                    }
                }
                jobGr.update();
            } else {
                gs.info('[_updateJobRecord] Given job is invalidated. Aborting further actions');
            }
        } else {
            gs.error('[_updateJobRecord] Scheduled job record for given sys_id (' + jobId + ') does not exist.');
        }
    },

    /**
     * Get critical label group name for given configuration
     * @param {String} configSysId SysId of PCE Configuration
     * @returns value of the critical label group
     **/
    getCritical: function(configSysId) {
        var criticalGroupConfig = {};
        var criticalConfigGr = new GlideRecord('x_illu2_illumio_illumio_critical_label_group_configuration');
        criticalConfigGr.addQuery('illumio_pce_configuration', configSysId);
        criticalConfigGr.query();
        while (criticalConfigGr.next()) {
            criticalGroupConfig[criticalConfigGr.illumio_label_dimension.key] = {
                groupName: criticalConfigGr.getValue('label_group'),
                visited: false,
            };
        }

        return criticalGroupConfig;
    },

    /**
     * Parse label information in the label group table
     * @param {Object} criticalGroupConfig JSON containing critical label group configuration
     * @param {Object} response Label Group details from PCE
     * @param {GlideRecord} pceConfig GlideRecord of PCE Configuration
     * @returns 
     */
    parseLabelsInResponse: function(criticalGroupConfig, response, pceConfig) {
        var labelGroupGr;

        for (var resIndex = 0; resIndex < response.length; resIndex++) {
            if (
                criticalGroupConfig[response[resIndex].key] &&
                criticalGroupConfig[response[resIndex].key]["groupName"].toUpperCase() ==
                response[resIndex].name.toUpperCase()
            ) {
                criticalGroupConfig[response[resIndex].key]['visited'] = true;
                for (var labelIndex = 0; labelIndex < response[resIndex].labels.length; labelIndex++) {
                    labelGroupGr = new GlideRecord('x_illu2_illumio_illumio_pce_label_group_details');
                    labelGroupGr.label_group_name = response[resIndex].name;
                    labelGroupGr.label_group_path = response[resIndex].href;
                    labelGroupGr.label_group_type = response[resIndex].key;
                    labelGroupGr.label_name = response[resIndex].labels[labelIndex].value;
                    labelGroupGr.label_path = response[resIndex].labels[labelIndex].href;
                    labelGroupGr.illumio_pce_configuration = pceConfig.getUniqueValue();
                    if (!labelGroupGr.insert()) {
                        gs.error(
                            '[parseLabelsInResponse] Error while inserting the record'
                        );
                    }
                }
            }
        }
        for (var type in criticalGroupConfig) {
            if (!criticalGroupConfig[type]['visited']) {
                gs.info('The Critical Label Group ({0}) for the Configuration named {1} does not match any label groups at PCE', [criticalGroupConfig[type]['groupName'], pceConfig.getDisplayValue()]);
            }
        }
    },


    /**
     * Fetch the details of label group from PCE
     * @param {GlideRecord} pceConfig GlideRecord of PCE Configuration
     * @returns {Boolean} true if the request was successfull else false
     */
    fetchLabelGroupsAndLabelsFromPCE: function(pceConfig) {
        try {
            var lgDetailsGr = new GlideRecord('x_illu2_illumio_illumio_pce_label_group_details');
            lgDetailsGr.addQuery('illumio_pce_configuration', pceConfig.getUniqueValue());
            lgDetailsGr.query();
            lgDetailsGr.deleteMultiple();

            var criticalGroupConfig = this.getCritical(pceConfig.getUniqueValue());

            if (!gs.nil(criticalGroupConfig)) {
                if (!(pceConfig.mid_server.status == MID_SERVER_UP_STATUS && pceConfig.mid_server.validated == 'true')) {
                    gs.error("The configured MID Server with configuration record " + pceConfig.getValue("name") + " is down.");
                    return false;
                }

                var inputs = {};
                inputs['pce_configuration'] = pceConfig; // GlideRecord of table: x_illu2_illumio_illumio_pce_conf
                inputs['query_parameters'] = "";

                var actionTimeout = gs.getProperty('x_illu2_illumio.flow_action_timeout') || 30000;
                var result = sn_fd.FlowAPI.getRunner().action('x_illu2_illumio.fetch_label_groups').inForeground().withInputs(inputs).timeout(actionTimeout).run();
                var outputs = result.getOutputs();

                var statusCode = outputs['status'];
                var headers = outputs['headers'];
                var response = outputs['response'];

                if (statusCode == 200 || statusCode == 201) {
                    response = JSON.parse(response);

                    this.parseLabelsInResponse(
                        criticalGroupConfig,
                        response,
                        pceConfig
                    );
                    return true;
                }
                return false;
            }
            return true;
        } catch (ex) {
            gs.error('Exception while fetching data from PCE. Error', ex);
            return false;
        }
    },

    /**
     * Fetch the details of label group from label groups table
     * @param {String} pceConfigSysId SysId of the PCE Configuration
     * @returns {JSON} JSON object of the critical label group and its labels
     */
    getDataFromTable: function(pceConfigSysId) {
        var criticalGroupConfig = this.getCritical(pceConfigSysId);
        var dataObj = {};
        if (!gs.nil(criticalGroupConfig)) {
            for (var type in criticalGroupConfig) {
                dataObj[type] = [];
                var labelGroupGr = new GlideRecord('x_illu2_illumio_illumio_pce_label_group_details');
                labelGroupGr.addQuery('illumio_pce_configuration', pceConfigSysId);
                labelGroupGr.addQuery('label_group_name', criticalGroupConfig[type]['groupName']);
                labelGroupGr.addQuery('label_group_type', type);
                labelGroupGr.query();
                while (labelGroupGr.next()) {
                    dataObj[type].push(labelGroupGr.getValue("label_name"));
                }
            }
        }
        return dataObj;
    },

    /**
     * Skip the workload with given sys id as it has critical labels
     * @param {Array} rec Array of records
     * @param {String} sys_id System id of the workload
     * @returns Modified array
     */
    removeRec: function(rec, sys_id) {
        var ax;
        while ((ax = rec.indexOf(sys_id + "")) !== -1) {
            gs.info("Skipped workload as label is critical (sys_id: " + sys_id + ")");
            rec.splice(ax, 1);
        }
        return rec;
    },

    /**
     * Get the count of label groups
     * @param {Object} configSysIds List of config sys Ids
     * @returns {object} Count object with number of label groups for each configuration
     */
    countLabelGroups: function(configSysIds) {
        var countObject = {};
        try {

            for (var configIndex in configSysIds) {
                var countGa = new GlideAggregate('x_illu2_illumio_illumio_pce_label_group_details');
                countGa.addQuery("illumio_pce_configuration", configSysIds[configIndex]);
                countGa.groupBy("label_group_name");
                countGa.query();
                countObject[configSysIds[configIndex]] = countGa.getRowCount();
            }
        } catch (err) {
            gs.error("Error while fetching the count of labels", err);
        } finally {
            return countObject;
        }
    },

    /**
     * Modify the Array after removing workloads
     * @param {Array} arrRecords Array of workloads
     * @returns Modified array after removing workloads that should be skipped
     */
    skipRecordsForSync: function(selectedRecordsObject) {
        try {
            var arrRecords, flag = false,
                retRec = [],
                retObject = {},
                totalRecords = 0;

            // for each configuration fetch critical label data
            for (var configSysId in selectedRecordsObject) {
                var labelData = this.getDataFromTable(configSysId);
                arrRecords = selectedRecordsObject[configSysId];
                retRec = [];

                // for each workload check if it contains critical label
                for (var arrIndex = 0; arrIndex < arrRecords.length; arrIndex++) {
                    flag = false;

                    // loop through all label dimensions
                    for (var type in labelData) {

                        if (gs.nil(labelData[type]) || labelData[type].length == 0)
                            continue;

                        var fieldValueGr = new GlideRecord('x_illu2_illumio_illumio_pce_workload_field_value');
                        fieldValueGr.addQuery('illumio_pce_workload', arrRecords[arrIndex]);
                        fieldValueGr.addQuery('illumio_label_dimension.key', type);
                        fieldValueGr.addQuery(
                            'pce_value',
                            'IN',
                            labelData[type]
                        );
                        fieldValueGr.query();

                        while (fieldValueGr.next()) {
                            if (fieldValueGr.getValue("cmdb_value") != fieldValueGr.getValue("pce_value")) {
                                flag = true;
                                break;
                            }
                        }

                        if (flag)
                            break;
                    }

                    if (!flag) {
                        retRec.push(arrRecords[arrIndex] + '');
                        totalRecords += 1;
                    } else {
                        gs.info('Skipped workload as label is critical (sys_id: {0})', arrRecords[arrIndex]);
                    }

                }
                retObject[configSysId] = retRec;
            }
        } catch (exc) {
            gs.error('Exception occurred while checking critical records', exc);
        } finally {
            return {
                filteredRecords: retObject,
                totalRecords: totalRecords
            };
        }
    },

    /**
     * Get the total number of records
     * @param {String} tableName Name of the table
     * @param {String} configuration SysID
     * @returns Count of rows in the table
     */
    getTotalRecords: function(tableName, configSysId) {
        try {

            var count = new GlideAggregate(tableName);
            count.addQuery("illumio_pce_configuration", configSysId);
            count.addAggregate('count');
            count.query();
            var result = 0;
            if (count.next())
                result = count.getAggregate('COUNT');
            return result;

        } catch (ex) {
            gs.error("Exception occurred while getting total number of records", ex);
        }
    },


    /**
     * Get the interfaces object that can be synced
     * @param {String} workloadSysId System id of the workload
     * @param {JSON} mappedFields object of Mapping fields
     * @returns {JSON} object with the details of interfaces to sync
     */
    getInterfacesObject: function(workloadGr) {

        var visitedIps = {},
            interfaces = [],
            state = {},
            key, cmdbKey, cmdbValue, publicIP;
        try {
            var interfaceObject = JSON.parse(workloadGr.getValue("interfaces"));
            var hostname = workloadGr.getValue("hostname");

            // get state of mapped cmdb ip addresses
            for (var index = 0; index <= MAX_IP_ADDRESSES; index++) {
                key = "umw" + index;
                if (!gs.nil(interfaceObject[key]))
                    state[key] = this.getState(interfaceObject[key]["cmdb_value"]);
            }

            // set umw0 as public ip address
            if (this.canSyncIP("umw0", state["umw0"], hostname)) {

                interfaces.push({
                    name: "umw0",
                    address: interfaceObject["umw0"]["cmdb_value"]
                });

                publicIP = interfaceObject["umw0"]["cmdb_value"];
                visitedIps[interfaceObject["umw0"]["cmdb_value"]] = true;

            }


            // set pce umw1 to umw32 ip addresses

            var cmdbIndex = 1;
            for (var ipindex = 1; ipindex < MAX_IP_ADDRESSES; ipindex++) {

                key = "umw" + ipindex;

                // set pce value
                if (!gs.nil(interfaceObject[key])) {
                    var pceValue = interfaceObject[key]["pce_value"];
                    if (!gs.nil(pceValue)) {
                        visitedIps[pceValue] = true;
                        interfaces.push({
                            name: key,
                            address: pceValue
                        });
                        continue;
                    }
                }

                // set valid cmdb value
                while (cmdbIndex < MAX_IP_ADDRESSES) {
                    cmdbKey = "umw" + cmdbIndex
                    if (gs.nil(interfaceObject[cmdbKey])) {
                        cmdbIndex++;
                        continue;
                    }

                    cmdbValue = interfaceObject[cmdbKey]["cmdb_value"];
                    if (this.canSyncIP(cmdbKey, state[cmdbKey], hostname) && !visitedIps[cmdbValue]) {
                        interfaces.push({
                            name: key,
                            address: cmdbValue
                        });
                        visitedIps[cmdbValue] = true;
                        cmdbIndex++;
                        break;
                    }
                    cmdbIndex++;
                }
            }

            // check for more IP addresses in the cmdb if exist then add logs
            while (cmdbIndex < MAX_IP_ADDRESSES) {
                cmdbKey = "umw" + cmdbIndex;

                if (gs.nil(interfaceObject[cmdbKey]))
                    break;

                cmdbValue = interfaceObject[cmdbKey]["cmdb_value"];
                if (gs.nil(visitedIps[cmdbValue]) && this.canSyncIP(cmdbKey, state[cmdbKey], hostname))
                    gs.info("Skipping IP address {0} for workload with hostname {1} as there are already {2} IP addresses in the PCE", [cmdbKey, hostname, MAX_IP_ADDRESSES]);

                cmdbIndex++;
            }
        } catch (ex) {
            gs.error("[getInterfacesObject] Exception occured while generating valid interfaces object. Exception", ex);
        } finally {
            return {
                interfaces: interfaces,
                publicIP: publicIP
            };
        }
    },

    /**
     * Checks if the IP is not empty, mapped in mappings and a valid ip
     * @param {int} index Index of the Ip address field
     * @param {string} ipAddress Value of the Ip address
     * @param {json} mappedFields Field Mapping from the configuration
     * @returns boolean
     */
    getState: function(cmdbValue) {
        if (gs.nil(cmdbValue))
            return STATES.EMPTY;
        var isValid = cmdbValue.match(this.VALID_IP_REGEX);
        if (isValid)
            return STATES.VALID;
        return STATES.INVALID;
    },

    /**
     * Checks if the IP is not empty, mapped in mappings and a valid ip
     * @param {int} index Index of the Ip address field
     * @param {string} state State array
     * @param {string} hostname Hostname of the workload
     * @returns boolean
     **/
    canSyncIP: function(key, state, hostname) {
        switch (state) {
            case STATES.INVALID:
                if (key != "umw0")
                    gs.error("Skipping IP address " + key + " for workload with hostname " + hostname + " as there is an invalid IP address");
                else
                    gs.error("Skipping Public IP address for workload with hostname " + hostname + " as there is an invalid IP address");
                return false;
            case STATES.NOT_MAPPED_AND_VALID:
                if (key != "umw0")
                    gs.error("Skipping IP address " + key + " for workload with hostname " + hostname + " as it is not mapped in field mapping");
                else
                    gs.error("Skipping Public IP address for workload with hostname " + hostname + " as it is not mapped in field mapping");
                return false;
            case STATES.VALID:
                return true;
            default:
                return false;
        }
    },
    /**
     * Check whether conflict is there or not in the workload
     * @param {GlideRecord} current GlideRecord of the Objectt
     * @param {JSON} mappedFields Object with the mapped fields
     * @returns true if there is any conflict else false
     */
    checkConflict: function(current, mappedFields) {
        try {

            if (!current || !mappedFields) {
                return false;
            }
            if (current.duplicate) {
                return false;
            }
            if (current.known_to_pce == 'unknown') {
                return true;
            }
            var sourceTable = current.getValue("source_table");
            var workloadFieldValueGr = new GlideRecord('x_illu2_illumio_illumio_pce_workload_field_value');
            workloadFieldValueGr.addQuery('illumio_pce_workload', current.getUniqueValue());
            workloadFieldValueGr.addQuery('illumio_label_dimension.key', "IN", mappedFields[sourceTable]);
            workloadFieldValueGr.query();

            while (workloadFieldValueGr.next()) {
                if (workloadFieldValueGr.getValue("cmdb_value") != workloadFieldValueGr.getValue("pce_value"))
                    return true;
            }

            if (current.getValue("known_to_pce") == "unmanaged") {
                var interfaces = JSON.parse(current.getValue("interfaces"));
                var visitedIPs = {},
                    key;

                if (!gs.nil(interfaces["umw0"]) && !gs.nil(interfaces["umw0"]["cmdb_value"]) && interfaces["umw0"]["cmdb_value"] != interfaces["umw0"]["pce_value"])
                    return true;

                for (key in interfaces) {
                    if (!gs.nil(interfaces[key]["pce_value"]))
                        visitedIPs[interfaces[key]["pce_value"]] = true;
                }

                for (key in interfaces) {
                    if (!gs.nil(interfaces[key]["cmdb_value"]) && !visitedIPs[interfaces[key]["cmdb_value"]])
                        return true;
                }

            }
            return false;
        } catch (ex) {
            gs.error("Exception while checking conflicts", ex);
        }
    },
    /**
     * Handles the error generated while any operation is in progress 
     * @param {integer} type Type of the error Client Side or Server side
     * @param {JSON} obj JSON object that accepts the GlideRecord of the caller, jobSysId if the type is client side and error
     */
    handleError: function(type, obj, current) {
        switch (type) {
            case CLIENT_ERROR_TYPE:
                gs.addErrorMessage(obj.message);
                gs.error(obj.message);
                if (current)
                    current.setAbortAction(true);
                break;
            case SERVER_ERROR_TYPE:
                break;
        }
    },
    /**
     * Validates the MID server and User to check if the JOb can start or not
     * @param {string} current GlideRecord of configuration table
     * @param {GlideRecord} midGr GlideRecord of the MID server
     * @returns {boolean} true if the validation is susccessful else false
     **/
    canStartJob: function(current, midGr) {
        var mid_server = midGr.getDisplayValue();
        if (!(midGr.status == MID_SERVER_UP_STATUS && midGr.validated == 'true')) {
            this.handleError(CLIENT_ERROR_TYPE, {
                message: "Configured MID server \"" + mid_server + "\" is either down or not validated"
            }, current);
            return false;
        }
        if (midGr.version + '' != MID_SERVER_VERSION) {
            this.handleError(CLIENT_ERROR_TYPE, {
                message: "Configured MID server \"" + mid_server + "\" is not up to date."
            }, current);
            return false;
        }
        //User roles validation
        var loggedUserGr = new GlideRecord('sys_user');
        loggedUserGr.addQuery('user_name', midGr.user_name);
        loggedUserGr.setLimit(1);
        loggedUserGr.query();
        if (loggedUserGr.next()) {
            var isMidUser = this.userHasRole(loggedUserGr.sys_id + '', MID_SERVER_USER_ROLE);
            var isIllumioMidUser = this.userHasRole(loggedUserGr.sys_id + '', ILLUMIO_MID_SERVER_ROLE);
            if (!isMidUser && isIllumioMidUser) {
                this.handleError(CLIENT_ERROR_TYPE, {
                    message: "The user which is configured in \"" + mid_server + "\" MID server does not have the 'mid_server' role."
                }, current);
                return false;
            }
            if (!isIllumioMidUser && isMidUser) {
                this.handleError(CLIENT_ERROR_TYPE, {
                    message: "The user which is configured in \"" + mid_server + "\" MID server does not have the 'x_illu2_illumio.mid_server_user' role."
                }, current);
                return false;
            }
            if (!isIllumioMidUser && !isMidUser) {
                this.handleError(CLIENT_ERROR_TYPE, {
                    message: "The user which is configured in \"" + mid_server + "\" MID server does not have the 'mid_server' and 'x_illu2_illumio.mid_server_user' roles."
                }, current);
                return false;
            }
        } else {
            this.handleError(CLIENT_ERROR_TYPE, {
                message: 'MID server user having user id ' + midGr.user_name + ' is not found in the Users(user_name) table.'
            }, current);
            return false;
        }
        return true;
    },

    /**
     * Checks if the user has the role
     * @param {string} userId User ID
     * @param {string} role Role to be checked
     * @returns {boolean} true if the user has the role else false
     **/
    userHasRole: function(u_id, role) {
        var userRoleGr = new GlideRecord('sys_user_has_role');
        userRoleGr.addQuery('user', u_id);
        userRoleGr.addQuery('role.name', role);
        userRoleGr.setLimit(1);
        userRoleGr.query();
        return userRoleGr.hasNext();
    },

    /**
     * Completes the process monitor with failed state
     * @param {String} jobSysId system id of the process monitor
     * @param {String} operation current operation
     * @param {String} message message to show in process monitor
     **/
    handleFailure: function(jobSysId, operation, message) {
        if (this.scheduledJobsGr.get(jobSysId)) {

            if (this.scheduledJobsGr.job_status == "cancelled") return;

            this.scheduledJobsGr.job_status = 'failed';
            this.scheduledJobsGr.logs += '\n[' + new Date(new GlideDateTime().getNumericValue()).toISOString() + '] ' + operation;
            this.scheduledJobsGr.logs += '\n[' + new Date(new GlideDateTime().getNumericValue()).toISOString() + '] Authentication failed';
            this.scheduledJobsGr.job_completed = new GlideDateTime();
            this.scheduledJobsGr.update();
            gs.error(message);
        } else {
            gs.error("Cannot find the scheduled job with sys_id: " + jobSysId);
        }
    },

    /**
     * Download the data from attachment
     * @param {string} tableName Name of the table to download attachment from
     * @param {string} tableSysId Sys id of the record
     * @returns Content of the attachment as a strin
     */
    downloadAttachmentData: function(tableName, tableSysId) {
        // Open the attachment on the record.
        var grAttachment = new GlideRecord('sys_attachment');
        grAttachment.addQuery('table_name', tableName);
        grAttachment.addQuery('table_sys_id', tableSysId);
        grAttachment.query();
        grAttachment.next();
        var streamData = new GlideSysAttachment().getContentStream(grAttachment.getUniqueValue());
        return new GlideTextReader(streamData).readLine();
    },

    /**
     * Query the case-sensitive GlideRecord 
     * @param {string} tableGr GlideRecord of the table
     * @param {string} key field of the table
     * @param {string} value value to be matched
     * @returns gr if found, else return JSON response as false
     */
    queryCaseSensitiveGr: function(tableGr, key, value, targetField) {

        while (tableGr.next()) {
            gs.info("Key in the IllumioUtils QueryCaseSensitive" + key);
            if (tableGr.getValue(key) == value) {
                return {
                    found: true,
                    returnValue: tableGr.getValue(targetField)
                };
            }
        }
        return {
            found: false
        };
    },

    /**
     * Persist records of  the provided configuration
     * @param {object} GlideRecord object of PCE configuration
     */
    persistLabelDimensions: function(pceConfig) {
        var labelDimensionGr = new GlideRecord("x_illu2_illumio_illumio_label_dimension");
        labelDimensionGr.addQuery("illumio_pce_configuration", pceConfig.getUniqueValue());
        labelDimensionGr.addNotNullQuery("href");
        labelDimensionGr.query();
        labelDimensionGr.setValue("isdeleted", false);
        labelDimensionGr.setWorkflow(false);
        labelDimensionGr.updateMultiple();
    },

    /**
     * Make REST API call to Illumio PCE
     * @params {String} the name of the RestMessage to be used
     * @params {String} the name of the HTTP Method to be used
     * @parmas {object} string parameters for the RESTMessage
     * @params {object} headers to be passed to the RestMessage
     * @params {object} body to be passed to the RestMessage
     * @params {String} the MID Server to be used
     * @returns {object} the response object returned by the API
     */
    makeRestCall: function(restMessage, httpMethod, stringParams, headers, body, midServer) {



        var apiCall = new sn_ws.RESTMessageV2(restMessage, httpMethod);

        apiCall.setRequestHeader('User-Agent', 'servicenow');

        if (!gs.nil(stringParams)) {
            Object.keys(stringParams).forEach(function(key) {
                apiCall.setStringParameter(key, stringParams[key]);
            });
        }
        if (!gs.nil(headers)) {
            Object.keys(headers).forEach(function(key) {
                apiCall.setRequestHeader(key, headers[key]);
            });
        }
        if (!gs.nil(body) && Object.keys(body).length > 1) {
            apiCall.setRequestBody(JSON.stringify(body));
        }
        if (!gs.nil(midServer)) {
            apiCall.setMIDServer(midServer);
            apiCall.setEccParameter("skip_sensor", "true");
        }
        return apiCall.executeAsync();
    },

    /**
     * Hit Illumio PCE API to get the label dimensions for a provided organisation
     * @param {String} pceConfig object of configuration
     * @returns {dict} Dict containing the status, response and response status code
     */
    getLabelDimensions: function(pceConfig) {
        try {
            var returnDict = {
                "status": false,
                "response": "",
                "statusCode": -1
            };

            if (!(pceConfig.mid_server.status == MID_SERVER_UP_STATUS && pceConfig.mid_server.validated == 'true')) {
                gs.error("The configured MID Server with configuration record " + pceConfig.getValue("name") + " is down.");
                return returnDict;
            }

            var inputs = {};
            inputs['pce_configuration'] = pceConfig; // GlideRecord of table: x_illu2_illumio_illumio_pce_conf 

            // Execute Synchronously: Run in foreground. Code snippet has access to outputs.
            var actionTimeout = gs.getProperty('x_illu2_illumio.flow_action_timeout') || 30000;
            var result = sn_fd.FlowAPI.getRunner().action('x_illu2_illumio.fetch_label_dimensions').inForeground().withInputs(inputs).timeout(actionTimeout).run();
            var outputs = result.getOutputs();

            // Get Outputs:
            returnDict["statusCode"] = outputs['variable']; // String
            returnDict["response"] = JSON.parse(outputs['variable1']); // JSON
            returnDict["status"] = true;

        } catch (exc) {
            gs.error("Exception while making the API call to get the label dimensions for PCE configuration " + pceConfig.getValue("name") + ". Error - " + exc);
        }
        return returnDict;
    },

    /**
     * Create/Update the label dimension record with the provided details
     * @param {dict} contains the label dimension object from the API response obtained from Illumio PCE
     * @param {object} GlideRecord of PCE Configuration
     */
    createOrUpdateLabelDimensionRecord: function(details, pceConfig) {
        try {
            var labelDimensionGr = new GlideRecord("x_illu2_illumio_illumio_label_dimension");
            labelDimensionGr.addQuery("key", details["key"]);
            labelDimensionGr.addQuery("illumio_pce_configuration", pceConfig.getUniqueValue());
            labelDimensionGr.query();
            if (!labelDimensionGr.next()) {
                labelDimensionGr.initialize();
                labelDimensionGr.setValue("key", details["key"]);
                labelDimensionGr.setValue("illumio_pce_configuration", pceConfig.getUniqueValue());
            }
            if (!gs.nil(details["display_info"])) {
                labelDimensionGr.setValue("label_type_initial", details["display_info"]["initial"]);
                labelDimensionGr.setValue("display_name_plural", details["display_info"]["display_name_plural"]);
            }
            labelDimensionGr.setValue("display_name_singular", details["display_name"]);
            labelDimensionGr.setValue("href", details["href"]);

            labelDimensionGr.setValue("isdeleted", false);

            labelDimensionGr.setWorkflow(false);
            labelDimensionGr.update();
        } catch (exc) {
            gs.warn("Error occured while creating/updating the record for Label Dimension " + details["key"] + ". ");
        }
    },

    /**
     * Fetch the details of label dimensions from PCE
     */
    fetchLabelDimensionsFromPCE: function() {
        try {
            var pceConfig = new GlideRecord("x_illu2_illumio_illumio_pce_conf");
            pceConfig.query();

            while (pceConfig.next()) {
                var responseDict = this.getLabelDimensions(pceConfig);
                if (responseDict && !responseDict["status"]) {
                    gs.error("Failed fetching of Label Dimensions from Illumio PCE for PCE configuration " + pceConfig.getValue("name") + ".");
                    this.persistLabelDimensions(pceConfig);
                    continue;
                }
                var response = responseDict["response"];
                response_status = responseDict["statusCode"];

                if (response_status >= 200 && response_status < 300) {

                    // Iterate over each dimension and intialize record, if not already present, and update it.
                    for (var i = 0; i < response.length; i++) {
                        this.createOrUpdateLabelDimensionRecord(response[i], pceConfig);
                    }
                    gs.debug("Successfully fetched " + response.length + " label dimensions from Illumio PCE for PCE configuration " + pceConfig.getValue("name") + ".");
                } else {
                    gs.error("Error while fetching label dimensions from Illumio PCE for PCE configuration " + pceConfig.getValue("name") + ". Status code - " + response_status + ". Response - " + JSON.stringify(response));
                    this.persistLabelDimensions(pceConfig);
                }
            }
        } catch (exc) {
            gs.error("Exception while fetching label dimensions from PCE. " + exc);
        }
    },

    /**
     * Fetch all label dimensions and check if a label dimension with same key is already present on Illumio PCE
     * @param {String} key for the newly created label dimension
     * @param {String} pceConfig sys_id of the configuration record
     * @returns {Boolean} status of whether the label dimension has to be created
     */
    validateLabelDimensionCreation: function(key, pceConfigSysId) {
        try {
            var matchFound = false;

            var pceConfig = new GlideRecord("x_illu2_illumio_illumio_pce_conf");
            if (pceConfig.get(pceConfigSysId)) {
                var responseDict = this.getLabelDimensions(pceConfig);
                if (!responseDict["status"]) {
                    return matchFound;
                }
                response = responseDict["response"];
                response_status = responseDict["statusCode"];

                if (response_status >= 200 && response_status < 300) {

                    // Iterate over each dimension and intialize record, if not already present, and update it.
                    for (var i = 0; i < response.length; i++) {
                        this.createOrUpdateLabelDimensionRecord(response[i], pceConfig);

                        if (response[i]["key"] == key) {
                            matchFound = true;
                            gs.debug("A label dimension with key " + key + " is already present on Illumio PCE for PCE configuration " + pceConfig.getValue("name") + ". Replacing the label dimension details with the ones obtained from Illumio PCE.");
                        }
                    }
                } else {
                    gs.error("Error while validating the creation of label dimension with key - " + key + " for the PCE configuration " + pceConfig.getValue("name") + ". Status code - " + response_status + ". Response - " + JSON.stringify(response));
                }
            }
        } catch (exc) {
            gs.error("Error while validating the creation of label dimension with key - " + key + ". Error - " + exc);
            return false;
        }
        return matchFound;
    },

    /**
     * Retry failed label dimension creation
     * When the label dimensions creation fails on PCE, this method is to be called with the next scheduled script execution while fetching the label dimensions.
     * This method would retry creating the label dimensions aaded on ServiceNow onto the coorelating Illumio PCE tenant.
     */
    retryFailedLabelDimensionCreation: function() {
        var labelDimensionGr = new GlideRecord("x_illu2_illumio_illumio_label_dimension");
        labelDimensionGr.addNullQuery("href");
        labelDimensionGr.query();
        while (labelDimensionGr.next()) {
            try {
                var details = {
                    "key": labelDimensionGr.getValue("key"),
                    "display_name_singular": labelDimensionGr.getValue("display_name_singular"),
                    "display_name_plural": labelDimensionGr.getValue("display_name_plural"),
                    "label_type_initial": labelDimensionGr.getValue("label_type_initial"),
                    "illumio_pce_configuration": labelDimensionGr.getValue("illumio_pce_configuration")
                };

                gs.debug("Trying to create label dimension " + details["key"] + " on Illumio PCE for PCE configuration " + details["illumio_pce_configuration"] + ".");

                var responseDict = this.createLabelDimensionsInPCE(details);
                if (responseDict["status"] && !gs.nil(responseDict["href"])) {
                    labelDimensionGr.setValue("href", responseDict["href"]);
                }

                // Mark the record to not be deleted
                labelDimensionGr.setValue("isdeleted", false);
                labelDimensionGr.setWorkflow(false);
                labelDimensionGr.update();
            } catch (exc) {
                gs.error("Error while retrying to create the label dimension " + labelDimensionGr.getValue("key") + ". Error - " + exc);
            }
        }
    },

    /**
     * Create a label dimension on Illumio PCE
     * @returns {dict} containing status and href
     */
    createLabelDimensionsInPCE: function(labelDimensionData) {
        var returnDict = {
            "status": false,
            "href": "",
        };
        try {
            var pceConfig = new GlideRecord("x_illu2_illumio_illumio_pce_conf");
            if (pceConfig.get(labelDimensionData["illumio_pce_configuration"])) {
                if (!(pceConfig.mid_server.status == MID_SERVER_UP_STATUS && pceConfig.mid_server.validated == 'true')) {
                    gs.error("The configured MID Server with configuration record " + pceConfig.getValue("name") + " is down.");
                    returnDict["status"] = false;
                    return returnDict;
                }

                var requestBody = {
                    "key": labelDimensionData["key"],
                    "display_name": labelDimensionData["display_name_singular"],
                    "display_info": {
                        "initial": labelDimensionData["label_type_initial"],
                        "display_name_plural": labelDimensionData["display_name_plural"]
                    }
                };

                var inputs = {};
                inputs['pce_configuration'] = pceConfig; // GlideRecord of table: x_illu2_illumio_illumio_pce_conf 
                inputs['request_body'] = JSON.stringify(requestBody); // JSON 

                // Execute Synchronously: Run in foreground. Code snippet has access to outputs.
                var actionTimeout = gs.getProperty('x_illu2_illumio.flow_action_timeout') || 30000;
                var result = sn_fd.FlowAPI.getRunner().action('x_illu2_illumio.create_label_dimensions').inForeground().withInputs(inputs).timeout(actionTimeout).run();
                var outputs = result.getOutputs();

                // Get Outputs:
                var response = JSON.parse(outputs['response']); // JSON
                var response_status = outputs['status']; // String

                if (response_status >= 200 && response_status < 300) {
                    returnDict["href"] = response["href"];
                    gs.debug("Label dimension " + labelDimensionData["key"] + " created successfully on Illumio PCE for PCE configuration " + pceConfig.getValue("name") + ".");
                    returnDict["status"] = true;
                } else if (response_status == 406) {
                    response = response[0];
                    gs.error("Error while creating label dimension " + labelDimensionData["key"] + " on Illumio PCE for PCE configuration " + pceConfig.getValue("name") + ". " + response["message"] + "");
                    returnDict["status"] = false;
                } else {
                    gs.error("Error while creating label dimension " + labelDimensionData["key"] + " on Illumio PCE for PCE configuration " + pceConfig.getValue("name") + ", it will be retried with the next scheduled script execution. Status code - " + response_status + ". Response - " + JSON.stringify(response));
                    returnDict["status"] = false;
                }
            }
        } catch (exc) {
            gs.error("Exception while creating label dimension on Illumio PCE. " + exc);
        }
        return returnDict;
    },

    /**
     * Update a label dimension on Illumio PCE
     * @returns {Boolean} containing status
     */
    updateLabelDimension: function(labelDimensionData) {
        try {
            var pceConfig = new GlideRecord("x_illu2_illumio_illumio_pce_conf");
            if (pceConfig.get(labelDimensionData["illumio_pce_configuration"])) {
                if (!(pceConfig.mid_server.status == MID_SERVER_UP_STATUS && pceConfig.mid_server.validated == 'true')) {
                    gs.error("The configured MID Server with configuration record " + pceConfig.getValue("name") + " is down.");
                    return false;
                }

                var body = {
                    "display_name": labelDimensionData["display_name_singular"],
                    "display_info": {
                        "initial": labelDimensionData["label_type_initial"],
                        "display_name_plural": labelDimensionData["display_name_plural"]
                    },
                };

                var inputs = {};
                inputs['pce_configuration'] = pceConfig; // GlideRecord of table: x_illu2_illumio_illumio_pce_conf 
                inputs['label_dimension_href'] = labelDimensionData["href"]; // String 
                inputs['request_body'] = JSON.stringify(body); // JSON 

                // Execute Synchronously: Run in foreground. Code snippet has access to outputs.
                var actionTimeout = gs.getProperty('x_illu2_illumio.flow_action_timeout') || 30000;
                var result = sn_fd.FlowAPI.getRunner().action('x_illu2_illumio.update_label_dimensions').inForeground().withInputs(inputs).timeout(actionTimeout).run();
                var outputs = result.getOutputs();

                // Get Outputs:
                var response_status = outputs['status']; // String
                var response = JSON.parse(outputs['response']); // JSON

                if (response_status >= 200 && response_status < 300) {
                    gs.debug("Label Dimension " + labelDimensionData["key"] + " updated successfully on Illumio PCE for PCE configuration " + pceConfig.getValue("name") + ".");
                    return true;
                } else {
                    gs.error("Error while updating label dimension " + labelDimensionData["key"] + " on Illumio PCE for PCE configuration " + pceConfig.getValue("name") + ". Status code - " + response_status + ". Response - " + JSON.stringify(response));
                    return false;
                }
            }
        } catch (exc) {
            gs.error("Exception while updating label dimension on Illumio PCE. " + exc);
        }
        return false;
    },

    /**
     * Get the SysId of PCE Configuration record
     * @param {string} jobSysId
     * @returns SysId of the PCE Configuration record
     */
    getConfigurationId: function(jobSysId) {
        var jobGr = new GlideRecord('x_illu2_illumio_illumio_scheduled_jobs');
        if (jobGr.get(jobSysId)) {
            return jobGr.getValue('illumio_pce_configuration');
        }
    },

    /**
     * Fetch label dimension sys_id
     * @param {String} labelDimensionKey key of the label dimension 
     * @param {String} pceConfigId sys_id of the PCE Configuration
     * @returns {String} sys_id of the label dimension
     */
    fetchLabelDimensionSysId: function(labelDimensionKey, pceConfigId) {
        var ldGr = new GlideRecord("x_illu2_illumio_illumio_label_dimension");
        ldGr.addQuery("illumio_pce_configuration", pceConfigId);
        ldGr.addQuery("key", labelDimensionKey);
        ldGr.setLimit(1);
        ldGr.query();
        if (ldGr.next())
            return ldGr.getUniqueValue();
        return "";
    },

    /**
     * prepare workload object with all the values
     * @param {Object} checkedRecords array of all selected workload's sys_ids 
     * @returns {Object}
     */
    getWorkloadData: function(checkedRecords) {
        var retObject = {},
            count = 0,
            configUtil = new IllumioGetPCEConfiguration(),
            thresholdLimit = new IllumioThresholdLimit(),
            autoSyncUtil = new IllumioAutoSyncWithPCE(),
            wlTypeOpMap = {
                "managed": "update",
                "unmanaged": "update",
                "unknown": "create"
            },
            cancelJobOnLimitExceed = false,
            limitExceeded = false,
            logMessage = {};

        // for each configuration fetch field mapping
        for (var configSysId in checkedRecords) {
            var workloadGr = new GlideRecord('x_illu2_illumio_illumio_pce_workload');
            var arrRecords = checkedRecords[configSysId],
                retVal = [];
            var mappedFields = configUtil.getMappedFields(configSysId);
            var wlLimitObject = thresholdLimit.getThresholdLimit(configSysId);
            var isLimitExceed = false;

            // for each sys_id prepare workload object
            for (var arrIndex = 0, len = arrRecords.length; arrIndex < len; arrIndex++) {
                workloadGr.initialize();
                if (workloadGr.get(arrRecords[arrIndex]) && workloadGr.getValue("duplicate") == "0") {
                    try {
                        var wlType = workloadGr.getValue("known_to_pce");
                        var operation = wlTypeOpMap[wlType];

                        // check if limit is configured and exceeded
                        if (!wlLimitObject["limitEnabled"] || !wlLimitObject["isLimitEnabled"][operation] || wlLimitObject["wlLimit"][operation] > 0) {

                            // prepare workload object
                            var wlObject = this.prepareWorkloadObject(workloadGr, mappedFields);

                            // prepare label data
                            wlObject = autoSyncUtil.getUseCreateLabelsList(configSysId, wlObject, wlObject.label_data);
                            var createLabelLength = wlObject.createlabels.length;

                            // check if label creation limit exceeds
                            if (createLabelLength == 0 || !wlLimitObject["limitEnabled"] || !wlLimitObject["isLimitEnabled"]["labelCreate"] || (wlLimitObject["wlLimit"]["labelCreate"] - createLabelLength) >= 0) {

                                // update limits
                                wlLimitObject["wlLimit"][operation] -= 1;
                                wlLimitObject["wlLimit"]["labelCreate"] -= createLabelLength;
                                retVal.push(wlObject);
                            } else {
                                isLimitExceed = true;
                                wlLimitObject["wlLimit"]["labelCreateLimitExceeded"] = true;

                                if (wlLimitObject.cancelJobOnLimitExceed) {
                                    retVal = [];
                                    cancelJobOnLimitExceed = true;
                                    break;
                                }
                            }
                        } else {
                            isLimitExceed = true;
                            wlLimitObject["wlLimit"][operation + "LimitExceeded"] = true;

                            if (wlLimitObject.cancelJobOnLimitExceed) {
                                retVal = [];
                                cancelJobOnLimitExceed = true;
                                break;
                            }
                        }
                    } catch (err) {
                        gs.info("Exception occured while preparing workload object. Error", err);
                    }
                }
            }

            // log info message
            if (isLimitExceed) {
                limitExceeded = true;
                logMessage[configSysId] = this.logLimitExceedMessage(wlLimitObject, configSysId);
            }
            retObject[configSysId] = retVal;
            count += retVal.length;
        }

        return {
            filteredRecords: retObject,
            totalRecords: count,
            cancelJobOnLimitExceed: cancelJobOnLimitExceed,
            limitExceeded: limitExceeded,
            logMessage: logMessage
        };
    },

    /**
     * Log message for thresold limit exceeded
     * @param {Object} wlLimitObject workload limit object
     * @param {String} configSysId sys_id of the PCE Configuration
     */
    logLimitExceedMessage: function(wlLimitObject, configSysId) {
        var message = [];

        if (wlLimitObject["wlLimit"]["createLimitExceeded"]) {
            message.push("workload creation");
        }

        if (wlLimitObject["wlLimit"]["updateLimitExceeded"]) {
            message.push("workload modification");
        }

        if (wlLimitObject["wlLimit"]["deleteLimitExceeded"]) {
            message.push("workload deletion");
        }

        if (wlLimitObject["wlLimit"]["labelCreateLimitExceeded"]) {
            message.push("label creation");
        }

        if (message.length > 1) {
            message = message.slice(0, -1).join(", ") + " and " + message.slice(-1);
            message += " limits have";
        } else {
            message += " limit has";
        }

        if (!wlLimitObject.cancelJobOnLimitExceed)
            message = "One or more workloads are skipped as " + message + " exceeded";
        else
            message = "Cancelled the job as " + message + " exceeded";

        gs.info(message + " for Illumio PCE Configuration with sys_id " + configSysId);
        return message;
    },

    /**
     * prepare workload object
     * @param {GlideRecord} workloadGr GlideRecord of Workload
     * @param {Object} mappedFields JSON object of mapped fields
     * @returns {Object}
     */
    prepareWorkloadObject: function(workloadGr, mappedFields) {
        var workloadFields = ["sys_id", "hostname", "known_to_pce", "conflicts", "duplicate", "pce_workload_href", "source_table"];
        var workloadObject = {},
            labelData = {};

        for (var fieldIndex in workloadFields) {
            workloadObject[workloadFields[fieldIndex]] = workloadGr.getValue(workloadFields[fieldIndex]);
        }
        // set update fields
        workloadObject["updateFields"] = mappedFields[workloadObject["source_table"]];

        // add label dimension details
        var labelGr = new GlideRecord("x_illu2_illumio_illumio_pce_workload_field_value");
        labelGr.addQuery("illumio_pce_workload", workloadObject["sys_id"]);
        labelGr.query();
        while (labelGr.next()) {
            var labelDimensionKey = labelGr.illumio_label_dimension.key + "";
            if (workloadObject["updateFields"].indexOf(labelDimensionKey) > -1) {
                if (!gs.nil(labelGr.getValue("cmdb_value")))
                    labelData[labelDimensionKey] = labelGr.getValue("cmdb_value");
            } else
                labelData[labelDimensionKey] = labelGr.getValue("pce_value");
        }

        workloadObject["label_data"] = labelData;

        // add interface data
        if (workloadObject["known_to_pce"] != "managed") {
            var interfaceObject = this.getInterfacesObject(workloadGr);
            workloadObject["interfaces"] = interfaceObject.interfaces;
            workloadObject["ip_address"] = interfaceObject.publicIP;
        }

        return workloadObject;
    },


    /**
     * Returns the job status in boolean for the current job SysId
     * @param {sys_id} jobSysId
     * @returns {Boolean} job status is cancelled or not
     **/

    getCancelledJobStatus: function(jobSysId) {

        var scheduledJobGr = new GlideRecord(
            'x_illu2_illumio_illumio_scheduled_jobs'
        );

        if (scheduledJobGr.next()) {
            if (scheduledJobGr.get(jobSysId)) {
                var job_status = scheduledJobGr.getValue('job_status');
                if (job_status == 'cancelled')
                    return true;
            }

        }

        return false;
    },

    /**
     * Get require parameter to create HttpClient object for given configuration
     * @param {String} configSysId SysId of PCE Configuration
     * @returns {Object} of Required parameters
     **/

    getHttpConfiguration: function(configSysId) {
        var pceConfig = new GlideRecord('x_illu2_illumio_illumio_pce_conf');
        if (pceConfig.get(configSysId)) {

            return {
                illumio_pce_configuration_id: configSysId,
                pce_url: String(pceConfig.pce_url),
                pce_authorization: gs.base64Encode(pceConfig.username.getDecryptedValue() + ':' + pceConfig.secret_key.getDecryptedValue()),
                time_zone: gs.getSession().getTimeZoneName(),
                enable_pce_mid_proxy: pceConfig.getValue("enable_proxy_between_pce_and_mid_server"),
                org_id: pceConfig.getValue("organization_id") || "1"
            };
        }
    },

    type: "IllumioUtils",
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2020-11-04 13:11:02</sys_created_on>
        <sys_id>b630a09ddb9020d01206fd641d9619df</sys_id>
        <sys_mod_count>422</sys_mod_count>
        <sys_name>IllumioUtils</sys_name>
        <sys_package display_value="Illumio" source="x_illu2_illumio">15314f1ddb882700dc9fabc5ca961943</sys_package>
        <sys_policy/>
        <sys_scope display_value="Illumio">15314f1ddb882700dc9fabc5ca961943</sys_scope>
        <sys_update_name>sys_script_include_b630a09ddb9020d01206fd641d9619df</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2025-03-24 05:06:27</sys_updated_on>
    </sys_script_include>
</record_update>
